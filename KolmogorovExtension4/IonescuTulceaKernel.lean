/-
Copyright (c) 2024 Etienne Marion. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Etienne Marion
-/
import KolmogorovExtension4.PTraj
import KolmogorovExtension4.DependsOn
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import KolmogorovExtension4.KolmogorovExtension
import Batteries.Data.Nat.Lemmas

open ENNReal Filter Finset Function MeasurableSpace MeasureTheory Preorder ProbabilityTheory Topology

variable {X : ‚Ñï ‚Üí Type*}

section castLemmas

private lemma Iic_pi_eq {a b : ‚Ñï} (h : a = b) :
    (Œ† i : Iic a, X i) = (Œ† i : Iic b, X i) := by cases h; rfl

private lemma cast_pi {s t : Set ‚Ñï} (h : s = t) (x : (i : s) ‚Üí X i) (i : t) :
    cast (congrArg (fun u : Set ‚Ñï ‚Ü¶ (Œ† i : u, X i)) h) x i = x ‚ü®i.1, h.symm ‚ñ∏ i.2‚ü© := by
  cases h; rfl

variable [‚àÄ n, MeasurableSpace (X n)]

private lemma measure_cast {a b : ‚Ñï} (h : a = b) (Œº : (n : ‚Ñï) ‚Üí Measure (Œ† i : Iic n, X i)) :
    (Œº a).map (cast (Iic_pi_eq h)) = Œº b := by
  subst h
  exact Measure.map_id

private lemma heq_measurableSpace_Iic_pi {a b : ‚Ñï} (h : a = b) :
    HEq (inferInstance : MeasurableSpace (Œ† i : Iic a, X i))
    (inferInstance : MeasurableSpace (Œ† i : Iic b, X i)) := by cases h; rfl

end castLemmas

section iterateInduction

/-- This function takes as input a tuple `(x_‚ÇÄ, ..., x_‚Çê)` and `ind` a function which
given `(y_‚ÇÄ, ...,y_‚Çô)` outputs `x_{n+1} : X (n + 1)`, and it builds an element of `Œ† n, X n`
by starting with `(x_‚ÇÄ, ..., x_‚Çê)` and then iterating `ind`. -/
def iterateInduction {a : ‚Ñï} (x : Œ† i : Iic a, X i)
    (ind : (n : ‚Ñï) ‚Üí (Œ† i : Iic n, X i) ‚Üí X (n + 1)) : Œ† n, X n
  | 0 => x ‚ü®0, mem_Iic.2 <| zero_le a‚ü©
  | k + 1 => if h : k + 1 ‚â§ a
      then x ‚ü®k + 1, mem_Iic.2 h‚ü©
      else ind k (fun i ‚Ü¶ iterateInduction x ind i)
  decreasing_by exact Nat.lt_succ.2 (mem_Iic.1 i.2)

lemma frestrictLe_iterateInduction {a : ‚Ñï} (x : Œ† i : Iic a, X i)
    (ind : (n : ‚Ñï) ‚Üí (Œ† i : Iic n, X i) ‚Üí X (n + 1)) :
    frestrictLe a (iterateInduction x ind) = x := by
  ext i
  simp only [frestrictLe_apply]
  obtain ‚ü®(zero | j), hj‚ü© := i <;> rw [iterateInduction]
  rw [dif_pos (mem_Iic.1 hj)]

end iterateInduction

section ProjectiveFamily

namespace MeasureTheory

/-! ### Projective families indexed by `Finset ‚Ñï` -/

variable [‚àÄ n, MeasurableSpace (X n)] {Œº : (n : ‚Ñï) ‚Üí Measure (Œ† i : Iic n, X i)}

/-- To check that a measure `ŒΩ` is the projective limit of a projective family of measures indexed
by `Finset ‚Ñï`, it is enough to check on intervals of the form `Iic n`, where `n` is larger than
a given integer. -/
theorem isProjectiveLimit_nat_iff' {Œº : (I : Finset ‚Ñï) ‚Üí Measure (Œ† i : I, X i)}
    (hŒº : IsProjectiveMeasureFamily Œº) (ŒΩ : Measure (Œ† n, X n)) (a : ‚Ñï) :
    IsProjectiveLimit ŒΩ Œº ‚Üî ‚àÄ ‚¶Én‚¶Ñ, n ‚â• a ‚Üí ŒΩ.map (frestrictLe n) = Œº (Iic n) := by
  refine ‚ü®fun h n _ ‚Ü¶ h (Iic n), fun h I ‚Ü¶ ?_‚ü©
  have := (I.sub_Iic.trans (Iic_subset_Iic.2 (le_max_left (I.sup id) a)))
  rw [‚Üê restrict‚ÇÇ_comp_restrict this, ‚Üê Measure.map_map, ‚Üê frestrictLe, h (le_max_right _ _), ‚Üê hŒº]
  all_goals fun_prop

/-- To check that a measure `ŒΩ` is the projective limit of a projective family of measures indexed
by `Finset ‚Ñï`, it is enough to check on intervals of the form `Iic n`. -/
theorem isProjectiveLimit_nat_iff {Œº : (I : Finset ‚Ñï) ‚Üí Measure (Œ† i : I, X i)}
    (hŒº : IsProjectiveMeasureFamily Œº) (ŒΩ : Measure (Œ† n, X n)) :
    IsProjectiveLimit ŒΩ Œº ‚Üî ‚àÄ n, ŒΩ.map (frestrictLe n) = Œº (Iic n) := by
  rw [isProjectiveLimit_nat_iff' hŒº _ 0]
  simp

variable (Œº : (n : ‚Ñï) ‚Üí Measure (Œ† i : Iic n, X i))

/-- Given a family of measures `Œº : (n : ‚Ñï) ‚Üí Measure (Œ† i : Iic n, X i)`, we can define a family
of measures indexed by `Finset ‚Ñï` by projecting the measures. -/
noncomputable def inducedFamily (S : Finset ‚Ñï) : Measure ((k : S) ‚Üí X k) :=
    (Œº (S.sup id)).map (restrict‚ÇÇ S.sub_Iic)

instance [‚àÄ n, SFinite (Œº n)] (I : Finset ‚Ñï) :
    SFinite (inducedFamily Œº I) := by rw [inducedFamily]; infer_instance

instance [‚àÄ n, IsFiniteMeasure (Œº n)] (I : Finset ‚Ñï) :
    IsFiniteMeasure (inducedFamily Œº I) := by rw [inducedFamily]; infer_instance

instance [‚àÄ n, IsZeroOrProbabilityMeasure (Œº n)] (I : Finset ‚Ñï) :
    IsZeroOrProbabilityMeasure (inducedFamily Œº I) := by rw [inducedFamily]; infer_instance

instance [‚àÄ n, IsProbabilityMeasure (Œº n)] (I : Finset ‚Ñï) :
    IsProbabilityMeasure (inducedFamily Œº I) := by
  rw [inducedFamily]
  exact isProbabilityMeasure_map (measurable_restrict‚ÇÇ _).aemeasurable

/-- Given a family of measures `Œº : (n : ‚Ñï) ‚Üí Measure (Œ† i : Iic n, X i)`, the induced family
equals `Œº` over the intervals `Iic n`. -/
theorem inducedFamily_Iic (n : ‚Ñï) : inducedFamily Œº (Iic n) = Œº n := by
  rw [inducedFamily, ‚Üê measure_cast (sup_Iic n) Œº]
  congr with x i
  rw [restrict‚ÇÇ, cast_pi (by rw [sup_Iic n])]

/-- Given a family of measures `Œº : (n : ‚Ñï) ‚Üí Measure (Œ† i : Iic n, X i)`, the induced family
will be projective only if `Œº` is projective, in the sense that if `a ‚â§ b`, then projecting
`Œº b` gives `Œº a`. -/
theorem isProjectiveMeasureFamily_inducedFamily
    (h : ‚àÄ a b : ‚Ñï, ‚àÄ hab : a ‚â§ b, (Œº b).map (frestrictLe‚ÇÇ hab) = Œº a) :
    IsProjectiveMeasureFamily (inducedFamily Œº) := by
  intro I J hJI
  have sls : J.sup id ‚â§ I.sup id := sup_mono hJI
  simp only [inducedFamily]
  rw [Measure.map_map, restrict‚ÇÇ_comp_restrict‚ÇÇ,
    ‚Üê restrict‚ÇÇ_comp_restrict‚ÇÇ J.sub_Iic (Iic_subset_Iic.2 sls), ‚Üê Measure.map_map, ‚Üê frestrictLe‚ÇÇ,
    h (J.sup id) (I.sup id) sls]
  all_goals fun_prop

end MeasureTheory

end ProjectiveFamily

namespace ProbabilityTheory.Kernel

section definition

variable {X : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (X n)]
  (Œ∫ : (n : ‚Ñï) ‚Üí Kernel (Œ† i : Iic n, X i) (X (n + 1))) [‚àÄ n, IsMarkovKernel (Œ∫ n)]

/-- Given a family of kernels `Œ∫ : (n : ‚Ñï) ‚Üí Kernel (Œ† i : Iic n, X i) (X (n + 1))`, and the
trajectory up to time `a` we can construct an additive content over cylinders. It corresponds
to composing the kernels, starting at time `a + 1`. -/
noncomputable def trajContent {a : ‚Ñï} (x‚ÇÄ : Œ† i : Iic a, X i) :
    AddContent (measurableCylinders X) :=
  kolContent (isProjectiveMeasureFamily_inducedFamily _
    (fun _ _ ‚Ü¶ ptraj_map_frestrictLe‚ÇÇ_apply (Œ∫ := Œ∫) x‚ÇÄ))

/-- The `trajContent Œ∫ x‚ÇÄ` of a cylinder indexed by first coordinates is given by `ptraj`. -/
theorem trajContent_cylinder {a b : ‚Ñï} (x‚ÇÄ : Œ† i : Iic a, X i)
    {S : Set (Œ† i : Iic b, X i)} (mS : MeasurableSet S) :
    trajContent Œ∫ x‚ÇÄ (cylinder _ S) = ptraj Œ∫ a b x‚ÇÄ S := by
  rw [trajContent, kolContent_cylinder _ mS, inducedFamily_Iic]

/-- The `trajContent` of a cylinder is equal to the integral of its indicator function against
`ptraj`. -/
theorem trajContent_eq_lmarginalPTraj {b : ‚Ñï} {S : Set (Œ† i : Iic b, X i)}
    (mS : MeasurableSet S) (x‚ÇÄ : Œ† n, X n) (a : ‚Ñï) :
    trajContent Œ∫ (frestrictLe a x‚ÇÄ) (cylinder _ S) =
      lmarginalPTraj Œ∫ a b ((cylinder _ S).indicator 1) x‚ÇÄ := by
  rw [trajContent_cylinder _ _ mS, ‚Üê lintegral_indicator_one mS, lmarginalPTraj]
  congr with x
  apply indicator_const_eq
  rw [mem_cylinder]
  congrm (fun i ‚Ü¶ ?_) ‚àà S
  simp [updateFinset, i.2]

/-- The cylinders of a product space indexed by `‚Ñï` can be seen as depending on the first
coordinates. -/
theorem cylinders_nat :
    measurableCylinders X = ‚ãÉ (a) (S) (_ : MeasurableSet S), {cylinder (Iic a) S} := by
  ext s
  simp only [mem_measurableCylinders, exists_prop, Set.mem_iUnion, mem_singleton]
  refine ‚ü®?_, fun ‚ü®N, S, mS, s_eq‚ü© ‚Ü¶ ‚ü®Iic N, S, mS, s_eq‚ü©‚ü©
  rintro ‚ü®t, S, mS, rfl‚ü©
  refine ‚ü®t.sup id, restrict‚ÇÇ t.sub_Iic ‚Åª¬π' S, measurable_restrict‚ÇÇ _ mS, ?_‚ü©
  unfold cylinder
  rw [‚Üê Set.preimage_comp, restrict‚ÇÇ_comp_restrict]
  exact Set.mem_singleton _

lemma trajContent_ne_top {a : ‚Ñï} (x : Œ† i : Iic a, X i)
    {s : Set (Œ† n, X n)} (hs : s ‚àà measurableCylinders X) :
    trajContent Œ∫ x s ‚â† ‚ä§ := by
  obtain ‚ü®N, S, mS, rfl‚ü© : ‚àÉ N S, MeasurableSet S ‚àß s = cylinder (Iic N) S := by
    simpa [cylinders_nat] using hs
  simp [trajContent_cylinder _ _ mS]

/-- This is an auxiliary result for `trajContent_tendsto_zero`. Consider `f` a sequence of bounded
measurable functions such that `f n` depends only on the first coordinates up to `a n`.
Assume that when integrating `f n` against `ptraj (k + 1) (a n)`, one gets a non-increasing
sequence of functions wich converges to `l`.
Assume then that there exists `Œµ` and `y : Œ† i : Iic k, X i` such that
when integrating `f n` against `ptraj k (a n) y`, you get something at least
`Œµ` for all `n`. Then there exists `z` such that this remains true when integrating
`f` against `ptraj (k + 1) (a n) (update y (k + 1) z)`. -/
theorem le_lmarginalPTraj_succ {f : ‚Ñï ‚Üí (Œ† n, X n) ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñï ‚Üí ‚Ñï}
    (hcte : ‚àÄ n, DependsOn (f n) (Iic (a n))) (mf : ‚àÄ n, Measurable (f n))
    {bound : ‚Ñù‚â•0‚àû} (fin_bound : bound ‚â† ‚àû) (le_bound : ‚àÄ n x, f n x ‚â§ bound) {k : ‚Ñï}
    (anti : ‚àÄ x, Antitone (fun n ‚Ü¶ lmarginalPTraj Œ∫ (k + 1) (a n) (f n) x))
    {l : (Œ† n, X n) ‚Üí ‚Ñù‚â•0‚àû}
    (htendsto : ‚àÄ x, Tendsto (fun n ‚Ü¶ lmarginalPTraj Œ∫ (k + 1) (a n) (f n) x) atTop (ùìù (l x)))
    (Œµ : ‚Ñù‚â•0‚àû) (y : Œ† i : Iic k, X i)
    (hpos : ‚àÄ x n, Œµ ‚â§ lmarginalPTraj Œ∫ k (a n) (f n) (updateFinset x _ y)) :
    ‚àÉ z, ‚àÄ x n,
      Œµ ‚â§ lmarginalPTraj Œ∫ (k + 1) (a n) (f n) (update (updateFinset x _ y) (k + 1) z) := by
  have _ n : Nonempty (X n) := by
    induction n using Nat.case_strong_induction_on with
    | hz => exact ‚ü®y ‚ü®0, mem_Iic.2 (zero_le _)‚ü©‚ü©
    | hi m hm =>
      have : Nonempty (Œ† i : Iic m, X i) :=
        ‚ü®fun i ‚Ü¶ @Classical.ofNonempty _ (hm i.1 (mem_Iic.1 i.2))‚ü©
      exact ProbabilityMeasure.nonempty ‚ü®Œ∫ m Classical.ofNonempty, inferInstance‚ü©
  -- `F‚Çô` is the integral of `f‚Çô` from time `k + 1` to `a‚Çô`.
  let F n : (Œ† n, X n) ‚Üí ‚Ñù‚â•0‚àû := lmarginalPTraj Œ∫ (k + 1) (a n) (f n)
  -- `F‚Çô` converges to `l` by hypothesis.
  have tendstoF x : Tendsto (F ¬∑ x) atTop (ùìù (l x)) := htendsto x
  -- Integrating `f‚Çô` between time `k` and `a‚Çô` is the same as integrating
  -- `F‚Çô` between time `k` and time `k + 1`.
  have f_eq x n : lmarginalPTraj Œ∫ k (a n) (f n) x = lmarginalPTraj Œ∫ k (k + 1) (F n) x := by
    simp_rw [F]
    obtain h | h | h := lt_trichotomy (k + 1) (a n)
    ¬∑ rw [‚Üê lmarginalPTraj_self k.le_succ h.le (mf n)]
    ¬∑ rw [‚Üê h, lmarginalPTraj_le _ le_rfl (mf n)]
    ¬∑ rw [lmarginalPTraj_le _ _ (mf n), (hcte n).lmarginalPTraj_le _ (mf n),
        (hcte n).lmarginalPTraj_le _ (mf n)]
      all_goals omega
  -- `F` is also a bounded sequence.
  have F_le n x : F n x ‚â§ bound := by
    simpa [F, lmarginalPTraj] using lintegral_le _ fun z ‚Ü¶ le_bound _ _
  -- By dominated convergence, the integral of `f‚Çô` between time `k` and time `a n` converges
  -- to the integral of `l` between time `k` and time `k + 1`.
  have tendsto_int x : Tendsto (fun n ‚Ü¶ lmarginalPTraj Œ∫ k (a n) (f n) x) atTop
      (ùìù (lmarginalPTraj Œ∫ k (k + 1) l x)) := by
    simp_rw [f_eq, lmarginalPTraj]
    exact tendsto_lintegral_of_dominated_convergence (fun _ ‚Ü¶ bound)
      (fun n ‚Ü¶ (measurable_lmarginalPTraj _ _ (mf n)).comp measurable_updateFinset)
      (fun n ‚Ü¶ Eventually.of_forall <| fun y ‚Ü¶ F_le n _)
      (by simp [fin_bound]) (Eventually.of_forall (fun _ ‚Ü¶ tendstoF _))
  -- By hypothesis, we have `Œµ ‚â§ lmarginalPTraj Œ∫ k (k + 1) (F n) (updateFinset x _ y)`,
  -- so this is also true for `l`.
  have Œµ_le_lint x : Œµ ‚â§ lmarginalPTraj Œ∫ k (k + 1) l (updateFinset x _ y) :=
    ge_of_tendsto (tendsto_int _) (by simp [hpos])
  let x_ : Œ† n, X n := Classical.ofNonempty
  -- We now have that the integral of `l` with respect to a probability measure is greater than `Œµ`,
  -- therefore there exists `x` such that `Œµ ‚â§ l(y, x)`.
  obtain ‚ü®x, hx‚ü© : ‚àÉ x, Œµ ‚â§ l (update (updateFinset x_ _ y) (k + 1) x) := by
    have : ‚à´‚Åª x, l (update (updateFinset x_ _ y) (k + 1) x) ‚àÇ(Œ∫ k y) ‚â† ‚àû :=
      ne_top_of_le_ne_top fin_bound <| lintegral_le _
        fun y ‚Ü¶ le_of_tendsto' (tendstoF _) <| fun _ ‚Ü¶ F_le _ _
    obtain ‚ü®x, hx‚ü© := exists_lintegral_le this
    refine ‚ü®x, (Œµ_le_lint x_).trans ?_‚ü©
    rwa [lmarginalPTraj_succ, frestrictLe_updateFinset]
    exact ENNReal.measurable_of_tendsto (by fun_prop) (tendsto_pi_nhds.2 htendsto)
  refine ‚ü®x, fun x' n ‚Ü¶ ?_‚ü©
  -- As `F` is a non-increasing sequence, we have `Œµ ‚â§ F‚Çô(y, x)` for any `n`.
  have := le_trans hx ((anti _).le_of_tendsto (tendstoF _) n)
  -- This part below is just to say that this is true for any `x : (i : Œπ) ‚Üí X i`,
  -- as `F‚Çô` technically depends on all the variables, but really depends only on the first `k + 1`.
  convert this using 1
  refine (hcte n).dependsOn_lmarginalPTraj _ (mf n) fun i hi ‚Ü¶ ?_
  simp only [update, updateFinset, mem_Iic, F]
  split_ifs with h1 h2 <;> try rfl
  rw [mem_coe, mem_Iic] at hi
  omega

/-- The indicator of a cylinder only depends on the variables whose the cylinder depends on. -/
theorem dependsOn_cylinder_indicator {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} {I : Finset Œπ}
    (S : Set ((i : I) ‚Üí Œ± i)) :
    DependsOn ((cylinder I S).indicator (1 : ((Œ† i, Œ± i) ‚Üí ‚Ñù‚â•0‚àû))) I :=
  fun x y hxy ‚Ü¶ indicator_const_eq _ (by simp [restrict_def, hxy])

/-- This is the key theorem to prove the existence of the `trajKernel`:
the `trajContent` of a decreasing sequence of cylinders with empty intersection
converges to `0`.

This implies the `œÉ`-additivity of `trajContent` (see `sigma_additive_addContent_of_tendsto_zero`),
which allows to extend it to the `œÉ`-algebra by Carath√©odory's theorem. -/
theorem trajContent_tendsto_zero {A : ‚Ñï ‚Üí Set (Œ† n, X n)}
    (A_mem : ‚àÄ n, A n ‚àà measurableCylinders X) (A_anti : Antitone A) (A_inter : ‚ãÇ n, A n = ‚àÖ)
    {p : ‚Ñï} (x‚ÇÄ : Œ† i : Iic p, X i) :
    Tendsto (fun n ‚Ü¶ trajContent Œ∫ x‚ÇÄ (A n)) atTop (ùìù 0) := by
  have _ n : Nonempty (X n) := by
    induction n using Nat.case_strong_induction_on with
    | hz => exact ‚ü®x‚ÇÄ ‚ü®0, mem_Iic.2 (zero_le _)‚ü©‚ü©
    | hi m hm =>
      have : Nonempty (Œ† i : Iic m, X i) :=
        ‚ü®fun i ‚Ü¶ @Classical.ofNonempty _ (hm i.1 (mem_Iic.1 i.2))‚ü©
      exact ProbabilityMeasure.nonempty ‚ü®Œ∫ m Classical.ofNonempty, inferInstance‚ü©
  -- `A‚Çô` is a cylinder, it can be written as `cylinder (Iic (a n)) S‚Çô`.
  have A_cyl n : ‚àÉ a S, MeasurableSet S ‚àß A n = cylinder (Iic a) S := by
    simpa [cylinders_nat] using A_mem n
  choose a S mS A_eq using A_cyl
  -- We write `œá‚Çô` for the indicator function of `A‚Çô`.
  let œá n := (A n).indicator (1 : (Œ† n, X n) ‚Üí ‚Ñù‚â•0‚àû)
  -- `œá‚Çô` is measurable.
  have mœá n : Measurable (œá n) := by
    simp_rw [œá, A_eq]
    exact (measurable_indicator_const_iff 1).2 <| (mS n).cylinder
  -- `œá‚Çô` only depends on the first coordinates.
  have œá_dep n : DependsOn (œá n) (Iic (a n)) := by
    simp_rw [œá, A_eq]
    exact dependsOn_cylinder_indicator _
  -- Therefore its integral against `ptraj Œ∫ k (a n)` is constant.
  have lma_const x y n :
      lmarginalPTraj Œ∫ p (a n) (œá n) (updateFinset x _ x‚ÇÄ) =
      lmarginalPTraj Œ∫ p (a n) (œá n) (updateFinset y _ x‚ÇÄ) := by
    refine (œá_dep n).dependsOn_lmarginalPTraj p (mœá n) fun i hi ‚Ü¶ ?_
    rw [mem_coe, mem_Iic] at hi
    simp [updateFinset, hi]
  -- As `(A‚Çô)` is non-increasing, so is `(œá‚Çô)`.
  have œá_anti : Antitone œá := fun m n hmn y ‚Ü¶ by
    apply Set.indicator_le fun a ha ‚Ü¶ ?_
    simp [œá, A_anti hmn ha]
  -- Integrating `œá‚Çô` further than the last coordinate it depends on does nothing.
  -- This is used to then show that the integral of `œá‚Çô` from time `k` is non-increasing.
  have lma_inv k M n (h : a n ‚â§ M) : lmarginalPTraj Œ∫ k M (œá n) = lmarginalPTraj Œ∫ k (a n) (œá n) :=
    (œá_dep n).lmarginalPTraj_right (mœá n) h le_rfl
  -- the integral of `œá‚Çô` from time `k` is non-increasing.
  have anti_lma k x : Antitone fun n ‚Ü¶ lmarginalPTraj Œ∫ k (a n) (œá n) x := by
    intro m n hmn
    simp only
    rw [‚Üê lma_inv k ((a n).max (a m)) n (le_max_left _ _),
      ‚Üê lma_inv k ((a n).max (a m)) m (le_max_right _ _)]
    exact lmarginalPTraj_mono _ _ (œá_anti hmn) _
  -- Therefore it converges to some function `l‚Çñ`.
  have this k x : ‚àÉ l, Tendsto (fun n ‚Ü¶ lmarginalPTraj Œ∫ k (a n) (œá n) x) atTop (ùìù l) := by
    obtain h | h := tendsto_of_antitone (anti_lma k x)
    ¬∑ rw [OrderBot.atBot_eq] at h
      exact ‚ü®0, h.mono_right <| pure_le_nhds 0‚ü©
    ¬∑ exact h
  choose l hl using this
  -- `l‚Çö` is constant because it is the limit of constant functions: we call it `Œµ`.
  have l_const x y : l p (updateFinset x _ x‚ÇÄ) = l p (updateFinset y _ x‚ÇÄ) := by
    have := hl p (updateFinset x _ x‚ÇÄ)
    simp_rw [lma_const x y] at this
    exact tendsto_nhds_unique this (hl p _)
  obtain ‚ü®Œµ, hŒµ‚ü© : ‚àÉ Œµ, ‚àÄ x, l p (updateFinset x _ x‚ÇÄ) = Œµ :=
      ‚ü®l p (updateFinset Classical.ofNonempty _ x‚ÇÄ), fun x ‚Ü¶ l_const _ _‚ü©
  -- As the sequence is decreasing, `Œµ ‚â§ ‚à´ œá‚Çô`.
  have hpos x n : Œµ ‚â§ lmarginalPTraj Œ∫ p (a n) (œá n) (updateFinset x _ x‚ÇÄ) :=
    hŒµ x ‚ñ∏ ((anti_lma p _).le_of_tendsto (hl p _)) n
  -- Also, the indicators are bounded by `1`.
  have œá_le n x : œá n x ‚â§ 1 := by
    apply Set.indicator_le
    simp
  -- We have all the conditions to apply `le_lmarginalPTraj_succ`.
  -- This allows us to recursively build a sequence `z` with the following property:
  -- for any `k ‚â• p` and `n`, integrating `œá n` from time `k` to time `a n`
  -- with the trajectory up to `k` being equal to `z` gives something greater than `Œµ`.
  choose! ind hind using
    fun k y h ‚Ü¶ le_lmarginalPTraj_succ Œ∫ œá_dep mœá (by norm_num : (1 : ‚Ñù‚â•0‚àû) ‚â† ‚àû)
      œá_le (anti_lma (k + 1)) (hl (k + 1)) Œµ y h
  let z := iterateInduction x‚ÇÄ ind
  have main k (hk : p ‚â§ k) : ‚àÄ x n,
      Œµ ‚â§ lmarginalPTraj Œ∫ k (a n) (œá n) (updateFinset x _ (frestrictLe k z)) := by
    induction k, hk using Nat.le_induction with
    | base => exact fun x n ‚Ü¶ by simpa [z, frestrictLe_iterateInduction] using hpos x n
    | succ k hn h =>
      intro x n
      rw [‚Üê update_updateFinset_eq]
      convert hind k (fun i ‚Ü¶ z i.1) h x n
      simp [z, iterateInduction, Nat.lt_succ.2 hn]
  -- We now want to prove that the integral of `œá‚Çô`, which is equal to the `trajContent`
  -- of `A‚Çô`, converges to `0`.
  have aux x n : trajContent Œ∫ x‚ÇÄ (A n) = lmarginalPTraj Œ∫ p (a n) (œá n) (updateFinset x _ x‚ÇÄ) := by
    simp_rw [œá, A_eq]
    nth_rw 1 [‚Üê frestrictLe_updateFinset x x‚ÇÄ]
    exact trajContent_eq_lmarginalPTraj _ (mS n) ..
  simp_rw [aux z]
  convert hl p _
  rw [hŒµ]
  -- Which means that we want to prove that `Œµ = 0`. But if `Œµ > 0`, then for any `n`,
  -- choosing `k > a‚Çô` we get `Œµ ‚â§ œá‚Çô(z‚ÇÄ, ..., z_{a‚Çô})` and therefore `z ‚àà A‚Çô`.
  -- This contradicts the fact that `(A‚Çô)` has an empty intersection.
  by_contra!
  have mem n : z ‚àà A n := by
    have : 0 < œá n z := by
      rw [‚Üê lmarginalPTraj_le Œ∫ (le_max_right p (a n)) (mœá n),
        ‚Üê updateFinset_frestrictLe (i := a n) z]
      simpa using lt_of_lt_of_le this.symm.bot_lt (main _ (le_max_left _ _) z n)
    exact Set.mem_of_indicator_ne_zero (ne_of_lt this).symm
  exact (A_inter ‚ñ∏ Set.mem_iInter.2 mem).elim

/-- The `trajContent` is sigma-subadditive. -/
theorem trajContent_sigma_subadditive {a : ‚Ñï} (x‚ÇÄ : Œ† i : Iic a, X i)
    ‚¶Éf : ‚Ñï ‚Üí Set (Œ† n, X n)‚¶Ñ (hf : ‚àÄ n, f n ‚àà measurableCylinders X)
    (hf_Union : (‚ãÉ n, f n) ‚àà measurableCylinders X) :
    trajContent Œ∫ x‚ÇÄ (‚ãÉ n, f n) ‚â§ ‚àë' n, trajContent Œ∫ x‚ÇÄ (f n) := by
  refine addContent_iUnion_le_of_addContent_iUnion_eq_tsum
    isSetRing_measurableCylinders (fun f hf hf_Union hf' ‚Ü¶ ?_) f hf hf_Union
  refine addContent_iUnion_eq_sum_of_tendsto_zero isSetRing_measurableCylinders
    (trajContent Œ∫ x‚ÇÄ) (fun s hs ‚Ü¶ trajContent_ne_top _ _ hs) ?_ hf hf_Union hf'
  exact fun s hs anti_s inter_s ‚Ü¶ trajContent_tendsto_zero Œ∫ hs anti_s inter_s x‚ÇÄ

/-- This function is the kernel given by the Ionescu-Tulcea theorem. -/
noncomputable def trajFun (a : ‚Ñï) (x‚ÇÄ : Œ† i : Iic a, X i) :
    Measure (Œ† n, X n) :=
  (trajContent Œ∫ x‚ÇÄ).measure isSetSemiring_measurableCylinders generateFrom_measurableCylinders.ge
    (trajContent_sigma_subadditive Œ∫ x‚ÇÄ)

theorem isProbabilityMeasure_trajFun (a : ‚Ñï) (x‚ÇÄ : Œ† i : Iic a, X i) :
    IsProbabilityMeasure (trajFun Œ∫ a x‚ÇÄ) where
  measure_univ := by
    rw [‚Üê cylinder_univ (Iic 0), trajFun, AddContent.measure_eq,
      trajContent_cylinder _ _ MeasurableSet.univ]
    ¬∑ exact measure_univ
    ¬∑ exact generateFrom_measurableCylinders.symm
    ¬∑ exact cylinder_mem_measurableCylinders _ _ MeasurableSet.univ

theorem isProjectiveLimit_trajFun (a : ‚Ñï) (x‚ÇÄ : Œ† i : Iic a, X i) :
    IsProjectiveLimit (trajFun Œ∫ a x‚ÇÄ) (inducedFamily (fun n ‚Ü¶ ptraj Œ∫ a n x‚ÇÄ)) := by
  refine isProjectiveLimit_nat_iff (isProjectiveMeasureFamily_inducedFamily _
    (fun _ _ ‚Ü¶ ptraj_map_frestrictLe‚ÇÇ_apply x‚ÇÄ)) _ |>.2 fun n ‚Ü¶ ?_
  ext s ms
  rw [Measure.map_apply (measurable_frestrictLe n) ms]
  have h_mem : (frestrictLe n) ‚Åª¬π' s ‚àà measurableCylinders X :=
    cylinder_mem_measurableCylinders _ _ ms
  rw [trajFun, AddContent.measure_eq, trajContent, kolContent_congr _ (frestrictLe n ‚Åª¬π' s) rfl ms]
  ¬∑ exact generateFrom_measurableCylinders.symm
  ¬∑ exact cylinder_mem_measurableCylinders _ _ ms

theorem measurable_trajFun (a : ‚Ñï) : Measurable (trajFun Œ∫ a) := by
  apply Measure.measurable_of_measurable_coe
  refine MeasurableSpace.induction_on_inter
    (C := fun t ht ‚Ü¶ Measurable (fun x‚ÇÄ ‚Ü¶ trajFun Œ∫ a x‚ÇÄ t))
    (s := measurableCylinders X) generateFrom_measurableCylinders.symm
    isPiSystem_measurableCylinders (by simp) (fun t ht ‚Ü¶ ?cylinder) (fun t mt ht ‚Ü¶ ?compl)
    (fun f disf mf hf ‚Ü¶ ?union)
  ¬∑ obtain ‚ü®N, S, mS, t_eq‚ü© : ‚àÉ N S, MeasurableSet S ‚àß t = cylinder (Iic N) S := by
      simpa [cylinders_nat] using ht
    simp_rw [trajFun, AddContent.measure_eq _ _ generateFrom_measurableCylinders.symm _ ht,
      trajContent, kolContent_congr _ t t_eq mS, inducedFamily]
    refine Measure.measurable_measure.1 ?_ _ mS
    exact (Measure.measurable_map _ (measurable_restrict‚ÇÇ _)).comp (measurable _)
  ¬∑ have := isProbabilityMeasure_trajFun Œ∫ a
    simpa [measure_compl mt (measure_ne_top _ _)] using Measurable.const_sub ht _
  ¬∑ simpa [measure_iUnion disf mf] using Measurable.ennreal_tsum hf

/-- *Ionescu-Tulcea Theorem* : Given a family of kernels `Œ∫ k` taking variables in `Iic k` with
value in `X (k+1)`, the kernel `trajKernel Œ∫ p` takes a variable `x` depending on the
variables `i ‚â§ p` and associates to it a kernel on trajectories depending on all variables,
where the entries with index `‚â§ p` are those of `x`, and then one follows iteratively the
kernels `Œ∫ p`, then `Œ∫ (p+1)`, and so on.

The fact that such a kernel exists on infinite trajectories is not obvious, and is the content of
the Ionescu-Tulcea theorem. -/
noncomputable def trajKernel (a : ‚Ñï) : Kernel (Œ† i : Iic a, X i) (Œ† n, X n) where
  toFun := trajFun Œ∫ a
  measurable' := measurable_trajFun Œ∫ a

theorem trajKernel_apply (a : ‚Ñï) (x‚ÇÄ : Œ† i : Iic a, X i) :
    trajKernel Œ∫ a x‚ÇÄ = trajFun Œ∫ a x‚ÇÄ := rfl

instance (p : ‚Ñï) : IsMarkovKernel (trajKernel Œ∫ p) :=
  ‚ü®fun _ ‚Ü¶ isProbabilityMeasure_trajFun ..‚ü©

theorem frestrictLe_trajKernel (a b : ‚Ñï) :
    (trajKernel Œ∫ a).map (frestrictLe b) = ptraj Œ∫ a b := by
  ext1 x‚ÇÄ
  rw [map_apply _ (measurable_frestrictLe _), trajKernel_apply, frestrictLe,
    isProjectiveLimit_trajFun, inducedFamily_Iic]

theorem frestrictLe_trajKernel_le {a b : ‚Ñï} (hab : a ‚â§ b) :
    (trajKernel Œ∫ b).map (frestrictLe a) =
      deterministic (frestrictLe‚ÇÇ hab) (measurable_frestrictLe‚ÇÇ _) := by
  rw [frestrictLe_trajKernel, ptraj_le]

theorem eq_trajKernel' {a : ‚Ñï} (n : ‚Ñï) (Œ∑ : Kernel (Œ† i : Iic a, X i) (Œ† n, X n))
    (hŒ∑ : ‚àÄ b ‚â• n, Œ∑.map (frestrictLe b) = ptraj Œ∫ a b) :
    Œ∑ = trajKernel Œ∫ a := by
  ext1 x‚ÇÄ
  refine ((isProjectiveLimit_trajFun _ _ _).unique ?_).symm
  rw [isProjectiveLimit_nat_iff' _ _ n]
  ¬∑ intro k hk
    rw [inducedFamily_Iic, ‚Üê map_apply _ (measurable_frestrictLe k), hŒ∑ k hk]
  ¬∑ exact (isProjectiveMeasureFamily_inducedFamily _ (fun _ _ ‚Ü¶ ptraj_map_frestrictLe‚ÇÇ_apply x‚ÇÄ))

theorem eq_trajKernel {a : ‚Ñï} (Œ∑ : Kernel (Œ† i : Iic a, X i) (Œ† n, X n))
    (hŒ∑ : ‚àÄ b, Œ∑.map (frestrictLe b) = ptraj Œ∫ a b) :
    Œ∑ = trajKernel Œ∫ a := eq_trajKernel' Œ∫ 0 Œ∑ fun b _ ‚Ü¶ hŒ∑ b

theorem trajKernel_comp_ptraj {a b : ‚Ñï} (hab : a ‚â§ b) :
    (trajKernel Œ∫ b) ‚àò‚Çñ (ptraj Œ∫ a b) = trajKernel Œ∫ a := by
  refine eq_trajKernel _ _ fun n ‚Ü¶ ?_
  ext x‚ÇÄ s ms
  simp_rw [map_apply' _ (measurable_frestrictLe _) _ ms,
    comp_apply' _ _ _ (measurable_frestrictLe n ms),
    ‚Üê Measure.map_apply (measurable_frestrictLe n) ms,
    ‚Üê map_apply (trajKernel Œ∫ b) (measurable_frestrictLe n), frestrictLe_trajKernel Œ∫ b n,
    ‚Üê comp_apply' _ _ _ ms, ptraj_comp_ptraj' n hab]

end definition

section Filtration

variable {Œπ : Type*} [Preorder Œπ] [LocallyFiniteOrderBot Œπ]
  {X : Œπ ‚Üí Type*} [‚àÄ i, MeasurableSpace (X i)]

/-- The canonical filtration on dependent functions indexed by `‚Ñï`, where `ùìï n` consists of
measurable sets depending only on coordinates `‚â§ n`. -/
def Filtration.pi_preorder : @Filtration ((i : Œπ) ‚Üí X i) Œπ _ inferInstance where
  seq n := (inferInstance : MeasurableSpace (Œ† i : Iic n, X i)).comap (frestrictLe n)
  mono' i j hij := by
    simp only
    rw [‚Üê frestrictLe‚ÇÇ_comp_frestrictLe hij, ‚Üê comap_comp]
    exact MeasurableSpace.comap_mono (measurable_frestrictLe‚ÇÇ _).comap_le
  le' n := (measurable_frestrictLe n).comap_le

variable {E : Type*} [NormedAddCommGroup E]

/-- If a function is strongly measurable with respect to the œÉ-algebra generated by the
first coordinates, then it only depends on those first coordinates. -/
theorem stronglyMeasurable_dependsOn {i : Œπ} {f : ((i : Œπ) ‚Üí X i) ‚Üí E}
    (mf : StronglyMeasurable[Filtration.pi_preorder i] f) : DependsOn f (Set.Iic i) :=
  fun _ _ h ‚Ü¶ eq_of_stronglyMeasurable_comap _ mf (dependsOn_frestrictLe i h)

end Filtration

open Filtration

variable {X : ‚Ñï ‚Üí Type*} [‚àÄ n, MeasurableSpace (X n)]
variable (Œ∫ : (k : ‚Ñï) ‚Üí Kernel ((i : Iic k) ‚Üí X i) (X (k + 1)))
variable [‚àÄ k, IsMarkovKernel (Œ∫ k)]

/-- This theorem shows that `trajKernel Œ∫ n` is, up to an equivalence, the product of
a determinstic kernel with another kernel. This is an intermediate result to compute integrals
with respect to this kernel. -/
theorem trajKernel_eq (n : ‚Ñï) :
    trajKernel Œ∫ n =
      (Kernel.id √ó‚Çñ (trajKernel Œ∫ n).map (Set.Ioi n).restrict).map (IicProdIoi n) := by
  refine (eq_trajKernel' _ (n + 1) _ fun a ha ‚Ü¶ ?_).symm
  ext x s ms
  rw [Kernel.map_map, map_apply' _ _ _ ms, id_prod_apply', map_apply']
  ¬∑ have : (frestrictLe a) ‚àò (IicProdIoi n) ‚àò (Prod.mk x) ‚àò (Set.Ioi n).restrict =
        (fun y (i : Iic a) ‚Ü¶ if hi : i.1 ‚â§ n then x ‚ü®i.1, mem_Iic.2 hi‚ü© else y i) ‚àò
          (frestrictLe a) := by
      ext x i
      by_cases hi : i.1 ‚â§ n <;> simp [hi, IicProdIoi]
    have hyp : Measurable (fun (y : Œ† i : Iic a, X i) (i : Iic a) ‚Ü¶
        if hi : i.1 ‚â§ n then x ‚ü®i.1, mem_Iic.2 hi‚ü© else y i) := by
      refine measurable_pi_lambda _ (fun i ‚Ü¶ ?_)
      by_cases hi : i.1 ‚â§ n <;> simp only [hi, ‚ÜìreduceDIte, measurable_const]
      exact measurable_pi_apply _
    rw [‚Üê Set.preimage_comp, ‚Üê Set.preimage_comp, Function.comp_assoc, this,
      ‚Üê map_apply' _ _ _ ms, ‚Üê map_map _ _ hyp, frestrictLe_trajKernel, map_apply' _ _ _ ms,
      ptraj_eq_prod, map_apply' _ _ _ (hyp ms), id_prod_apply',
      map_apply' _ _ _ ms, id_prod_apply']
    ¬∑ congr with y
      simp only [IicProdIoc_def, Set.mem_preimage]
      congrm (fun i ‚Ü¶ ?_) ‚àà s
      by_cases hi : i.1 ‚â§ n <;> simp [hi]
    any_goals fun_prop
    ¬∑ exact measurable_IicProdIoc ms
    ¬∑ exact measurable_IicProdIoc <| hyp ms
    ¬∑ exact hyp
    ¬∑ exact hyp.comp (measurable_frestrictLe _)
  any_goals fun_prop
  ¬∑ exact measurable_prod_mk_left <| (IicProdIoi n).measurable <| (measurable_frestrictLe a) ms
  ¬∑ exact (IicProdIoi n).measurable <| (measurable_frestrictLe a) ms

@[measurability, fun_prop]
theorem measurable_updateFinset' {Œπ : Type*} [DecidableEq Œπ] {I : Finset Œπ}
    {X : Œπ ‚Üí Type*} [‚àÄ i, MeasurableSpace (X i)]
    {y : Œ† i : I, X i} : Measurable (fun x ‚Ü¶ updateFinset x I y) := by
  refine measurable_pi_lambda _ (fun i ‚Ü¶ ?_)
  by_cases hi : i ‚àà I <;> simp only [updateFinset, hi, ‚ÜìreduceDIte, measurable_const]
  exact measurable_pi_apply _

theorem trajKernel_map_updateFinset {n : ‚Ñï} (x‚ÇÄ : Œ† i : Iic n, X i) :
    (trajKernel Œ∫ n x‚ÇÄ).map (fun y ‚Ü¶ updateFinset y _ x‚ÇÄ) = trajKernel Œ∫ n x‚ÇÄ := by
  ext s ms
  nth_rw 2 [trajKernel_eq]
  have : (fun y ‚Ü¶ updateFinset y _ x‚ÇÄ) = (IicProdIoi n ‚àò (Prod.mk x‚ÇÄ) ‚àò (Set.Ioi n).restrict) := by
    ext x i
    simp [IicProdIoi, updateFinset]
  rw [this, map_apply' _ _ _ ms, ‚Üê Measure.map_map, Measure.map_apply _ ms, id_prod_apply',
    ‚Üê Measure.map_map, Measure.map_apply, map_apply]
  any_goals fun_prop
  all_goals exact (IicProdIoi n).measurable ms

variable {E : Type*} [NormedAddCommGroup E]

theorem integrable_trajKernel {a b : ‚Ñï} (hab : a ‚â§ b) {f : (Œ† n, X n) ‚Üí E}
    (x‚ÇÄ : Œ† i : Iic a, X i) (i_f : Integrable f (trajKernel Œ∫ a x‚ÇÄ)) :
    ‚àÄ·µê x ‚àÇtrajKernel Œ∫ a x‚ÇÄ, Integrable f (trajKernel Œ∫ b (frestrictLe b x)) := by
  rw [‚Üê trajKernel_comp_ptraj _ hab, integrable_comp_iff] at i_f
  ¬∑ apply ae_of_ae_map (p := fun x ‚Ü¶ Integrable f (trajKernel Œ∫ b x))
    ¬∑ exact (measurable_frestrictLe b).aemeasurable
    ¬∑ convert i_f.1
      rw [‚Üê frestrictLe_trajKernel, Kernel.map_apply _ (measurable_frestrictLe _)]
  ¬∑ exact i_f.aestronglyMeasurable

theorem aestronglyMeasurable_trajKernel {a b : ‚Ñï} (hab : a ‚â§ b)
    {f : (Œ† n, X n) ‚Üí E} {x‚ÇÄ : Œ† i : Iic a, X i}
    (hf : AEStronglyMeasurable f (trajKernel Œ∫ a x‚ÇÄ)) :
    ‚àÄ·µê x ‚àÇptraj Œ∫ a b x‚ÇÄ, AEStronglyMeasurable f (trajKernel Œ∫ b x) := by
  rw [‚Üê trajKernel_comp_ptraj Œ∫ hab] at hf
  exact hf.comp

variable [NormedSpace ‚Ñù E]

variable {Œ∫} in
/-- When computing `‚à´ x, f x ‚àÇtrajKernel Œ∫ n x‚ÇÄ`, because the trajectory up to time `n` is
determined by `x‚ÇÄ` we can replace `x` by `updateFinset x _ x‚ÇÄ`. -/
theorem integral_trajKernel {n : ‚Ñï} (x‚ÇÄ : Œ† i : Iic n, X i) {f : (Œ† n, X n) ‚Üí E}
    (mf : AEStronglyMeasurable f (trajKernel Œ∫ n x‚ÇÄ)) :
    ‚à´ x, f x ‚àÇtrajKernel Œ∫ n x‚ÇÄ = ‚à´ x, f (updateFinset x _ x‚ÇÄ) ‚àÇtrajKernel Œ∫ n x‚ÇÄ := by
  nth_rw 1 [‚Üê trajKernel_map_updateFinset, integral_map]
  ¬∑ exact measurable_updateFinset'.aemeasurable
  ¬∑ convert mf
    nth_rw 2 [‚Üê trajKernel_map_updateFinset]

lemma ptraj_comp_ptrajProd_trajKernel {a b : ‚Ñï} (hab : a ‚â§ b) (u : Œ† i : Iic a, X i) :
    (trajKernel Œ∫ a u).map (fun x ‚Ü¶ (frestrictLe b x, x)) =
      (ptraj Œ∫ a b u) ‚äó‚Çò (trajKernel Œ∫ b) := by
  ext s ms
  rw [Measure.map_apply (by fun_prop) ms, Measure.compProd_apply ms, ‚Üê trajKernel_comp_ptraj Œ∫ hab,
    comp_apply' _ _ _ (ms.preimage (by fun_prop))]
  conv_rhs => enter [2]; ext a; rw [‚Üê trajKernel_map_updateFinset]
  conv_lhs =>
    enter [2]
    ext a
    rw [‚Üê trajKernel_map_updateFinset, Measure.map_apply measurable_updateFinset']
    rfl
    exact ((measurable_frestrictLe b).prod_mk measurable_id) ms
  simp_rw [Measure.map_apply measurable_updateFinset' (measurable_prod_mk_left ms),
    ‚Üê Set.preimage_comp]
  congrm ‚à´‚Åª x, (trajKernel _ _ _) ((fun y ‚Ü¶ ?_) ‚Åª¬π' _) ‚àÇ_
  ext i <;> simp [updateFinset]

variable {Œ∫}

theorem integral_trajKernel_ptraj' {a b : ‚Ñï} (hab : a ‚â§ b) {x‚ÇÄ : Œ† i : Iic a, X i}
    {f : (Œ† i : Iic b, X i) ‚Üí (Œ† n : ‚Ñï, X n) ‚Üí E}
    (hf : Integrable f.uncurry ((ptraj Œ∫ a b x‚ÇÄ) ‚äó‚Çò (trajKernel Œ∫ b))) :
    ‚à´ x, ‚à´ y, f x y ‚àÇtrajKernel Œ∫ b x ‚àÇptraj Œ∫ a b x‚ÇÄ =
      ‚à´ x, f (frestrictLe b x) x ‚àÇtrajKernel Œ∫ a x‚ÇÄ := by
  have hf1 := hf
  rw [‚Üê ptraj_comp_ptrajProd_trajKernel Œ∫ hab] at hf1
  replace hf1 := hf1.comp_measurable (by fun_prop)
  have hf2 := aestronglyMeasurable_trajKernel Œ∫ hab hf1.1
  rw [‚Üê trajKernel_comp_ptraj Œ∫ hab, Kernel.integral_comp]
  ¬∑ apply integral_congr_ae
    filter_upwards [hf.1.compProd, hf2]
    intro x h1 h2
    rw [integral_trajKernel _ h1]
    nth_rw 2 [integral_trajKernel]
    ¬∑ simp_rw [frestrictLe_updateFinset]
    ¬∑ exact h2
  ¬∑ rwa [trajKernel_comp_ptraj _ hab]

theorem integral_trajKernel_ptraj {a b : ‚Ñï} (hab : a ‚â§ b) {x‚ÇÄ : Œ† i : Iic a, X i}
    {f : (Œ† n : ‚Ñï, X n) ‚Üí E} (hf : Integrable f (trajKernel Œ∫ a x‚ÇÄ)) :
    ‚à´ x, ‚à´ y, f y ‚àÇtrajKernel Œ∫ b x ‚àÇptraj Œ∫ a b x‚ÇÄ = ‚à´ x, f x ‚àÇtrajKernel Œ∫ a x‚ÇÄ := by
  apply integral_trajKernel_ptraj' hab
  rw [‚Üê trajKernel_comp_ptraj Œ∫ hab, ‚Üê snd_compProd_kernel] at hf
  exact hf.comp_measurable measurable_snd

-- theorem setIntegral_trajKernel_ptraj' {a b : ‚Ñï} (hab : a ‚â§ b) {u : (Œ† i : Iic a, X i)}
--     {f : (Œ† i : Iic b, X i) ‚Üí (Œ† n : ‚Ñï, X n) ‚Üí E}
--     (hf : Integrable f.uncurry ((ptraj Œ∫ a b u) ‚äó‚Çò (trajKernel Œ∫ b)))
--     {A : Set (Œ† n, X n)} (hA : MeasurableSet[pi_preorder b] A) :
--     ‚à´ x in A, ‚à´ y, f x y ‚àÇtrajKernel Œ∫ b (frestrictLe b x) ‚àÇtrajKernel Œ∫ a u =
--       ‚à´ y in A, f (frestrictLe b y) y ‚àÇtrajKernel Œ∫ a u := by
--   simp_rw [setIntegral_eq _ hA, ‚Üê integral_smul]
--   rw [integral_trajKernel_ptraj' hab]
--   simp_rw [‚Üê preimage_indicator, ‚Üê setIntegral_eq _ (measurable_frestrictLe b hA)]
--   refine hf.smul_of_top_right <| mem‚Ñíp_top_of_bound (C := 1)
--     (((measurable_indicator_const_iff 1).2 hA).comp measurable_fst).aestronglyMeasurable
--     <| Eventually.of_forall fun x ‚Ü¶ ?_
--   by_cases hx : x.1 ‚àà A <;> simp [hx]

theorem setIntegral_trajKernel_ptraj' {a b : ‚Ñï} (hab : a ‚â§ b) {u : (Œ† i : Iic a, X i)}
    {f : (Œ† i : Iic b, X i) ‚Üí (Œ† n : ‚Ñï, X n) ‚Üí E}
    (hf : Integrable f.uncurry ((ptraj Œ∫ a b u) ‚äó‚Çò (trajKernel Œ∫ b)))
    {A : Set (Œ† i : Iic b, X i)} (hA : MeasurableSet A) :
    ‚à´ x in A, ‚à´ y, f x y ‚àÇtrajKernel Œ∫ b x ‚àÇptraj Œ∫ a b u =
      ‚à´ y in frestrictLe b ‚Åª¬π' A, f (frestrictLe b y) y ‚àÇtrajKernel Œ∫ a u := by
  simp_rw [setIntegral_eq _ hA, ‚Üê integral_smul]
  rw [integral_trajKernel_ptraj' hab]
  simp_rw [‚Üê preimage_indicator, ‚Üê setIntegral_eq _ (measurable_frestrictLe b hA)]
  refine hf.smul_of_top_right <| mem‚Ñíp_top_of_bound (C := 1)
    (((measurable_indicator_const_iff 1).2 hA).comp measurable_fst).aestronglyMeasurable
    <| Eventually.of_forall fun x ‚Ü¶ ?_
  by_cases hx : x.1 ‚àà A <;> simp [hx]

theorem setIntegral_trajKernel_ptraj {a b : ‚Ñï} (hab : a ‚â§ b) {x‚ÇÄ : (Œ† i : Iic a, X i)}
    {f : (Œ† n : ‚Ñï, X n) ‚Üí E} (hf : Integrable f (trajKernel Œ∫ a x‚ÇÄ))
    {A : Set (Œ† i : Iic b, X i)} (hA : MeasurableSet A) :
    ‚à´ x in A, ‚à´ y, f y ‚àÇtrajKernel Œ∫ b x ‚àÇptraj Œ∫ a b x‚ÇÄ =
      ‚à´ y in frestrictLe b ‚Åª¬π' A, f y ‚àÇtrajKernel Œ∫ a x‚ÇÄ := by
  refine setIntegral_trajKernel_ptraj' hab ?_ hA
  rw [‚Üê trajKernel_comp_ptraj Œ∫ hab, ‚Üê snd_compProd_kernel] at hf
  exact hf.comp_measurable measurable_snd

variable [CompleteSpace E]

theorem condExp_trajKernel
    {a b : ‚Ñï} (hab : a ‚â§ b) {x‚ÇÄ : Œ† i : Iic a, X i} {f : (Œ† n, X n) ‚Üí E}
    (i_f : Integrable f (trajKernel Œ∫ a x‚ÇÄ)) :
    (trajKernel Œ∫ a x‚ÇÄ)[f|pi_preorder b] =·µê[trajKernel Œ∫ a x‚ÇÄ]
      fun x ‚Ü¶ ‚à´ y, f y ‚àÇtrajKernel Œ∫ b (frestrictLe b x) := by
  have mf : Integrable (fun x ‚Ü¶ ‚à´ y, f y ‚àÇ(trajKernel Œ∫ b) x)
      (((trajKernel Œ∫ a) x‚ÇÄ).map (frestrictLe b)) := by
    rw [‚Üê map_apply _ (measurable_frestrictLe _), frestrictLe_trajKernel _ _]
    rw [‚Üê trajKernel_comp_ptraj _ hab] at i_f
    exact i_f.integral_comp
  refine ae_eq_condExp_of_forall_setIntegral_eq (pi_preorder.le _) i_f
    (fun s _ _ ‚Ü¶
      (integrable_map_measure mf.1 (measurable_frestrictLe b).aemeasurable).1 mf |>.integrableOn)
    ?_ (mf.1.comp_ae_measurable' (measurable_frestrictLe b).aemeasurable) |>.symm
  rintro - ‚ü®t, mt, rfl‚ü© -
  simp_rw [Function.comp_apply]
  rw [‚Üê setIntegral_map mt mf.1, ‚Üê map_apply, frestrictLe_trajKernel,
    setIntegral_trajKernel_ptraj hab i_f mt]
  any_goals fun_prop

variable (Œ∫)

theorem condExp_trajKernel' {a b c : ‚Ñï} (hab : a ‚â§ b) (hbc : b ‚â§ c)
    (x‚ÇÄ : Œ† i : Iic a, X i) (f : (Œ† n, X n) ‚Üí E) :
    (trajKernel Œ∫ a x‚ÇÄ)[f|pi_preorder b] =·µê[trajKernel Œ∫ a x‚ÇÄ]
      fun x ‚Ü¶ ‚à´ y, ((trajKernel Œ∫ a x‚ÇÄ)[f|pi_preorder c]) (updateFinset x _ y)
        ‚àÇptraj Œ∫ b c (frestrictLe b x) := by
  have i_cf : Integrable ((trajKernel Œ∫ a x‚ÇÄ)[f|pi_preorder c]) (trajKernel Œ∫ a x‚ÇÄ) :=
    integrable_condExp
  have mcf : StronglyMeasurable ((trajKernel Œ∫ a x‚ÇÄ)[f|pi_preorder c]) :=
    stronglyMeasurable_condExp.mono (pi_preorder.le c)
  filter_upwards [pi_preorder.condExp_condExp f hbc, condExp_trajKernel hab i_cf]
  intro x h1 h2
  rw [‚Üê h1, h2, ‚Üê frestrictLe_trajKernel, Kernel.map_apply, integral_map]
  ¬∑ congr with y
    apply stronglyMeasurable_dependsOn stronglyMeasurable_condExp
    simp only [Set.mem_Iic, updateFinset, mem_Iic, frestrictLe_apply, dite_eq_ite]
    exact fun i hi ‚Ü¶ (if_pos hi).symm
  any_goals fun_prop
  ¬∑ exact (mcf.comp_measurable measurable_updateFinset).aestronglyMeasurable
